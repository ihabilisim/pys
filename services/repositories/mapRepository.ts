
import { supabase } from '../supabase';
import { PolygonPoint, ExternalMapLayer, DesignLayer, MapNote, SitePhoto, UtilityCategory } from '../../types';
import { logError, mapPolygonFromDB } from '../dbUtils';
import { DEMO_UTILITY_CATS } from '../../data/Settings';

export const mapRepository = {
  // --- UTILITIES & LAYERS ---
  async fetchUtilityCategories(): Promise<UtilityCategory[]> { if (!supabase) return DEMO_UTILITY_CATS; try { const { data, error } = await supabase.from('utility_categories').select('*').order('name_tr'); if (error) { logError("utility_categories", error); return DEMO_UTILITY_CATS; } return (data || []).map((c: any) => ({ id: c.id, name: { tr: c.name_tr, en: c.name_en || '', ro: c.name_ro || '' }, color: c.color })); } catch(e) { logError('utility_categories_ex', e); return DEMO_UTILITY_CATS; } },
  async addUtilityCategory(cat: Omit<UtilityCategory, 'id'>): Promise<UtilityCategory | null> { if (!supabase) return null; const { data, error } = await supabase.from('utility_categories').insert({ name_tr: cat.name.tr, name_en: cat.name.en, name_ro: cat.name.ro, color: cat.color }).select().single(); return error ? null : { id: data.id, name: { tr: data.name_tr, en: data.name_en || '', ro: data.name_ro || '' }, color: data.color }; },
  async deleteUtilityCategory(id: string): Promise<boolean> { if (!supabase) return false; const { error } = await supabase.from('utility_categories').delete().eq('id', id); return !error; },
  async fetchMapLayers(): Promise<ExternalMapLayer[]> { if (!supabase) return []; try { const { data, error } = await supabase.from('utility_layers').select('*'); if (error) { logError("utility_layers", error); return []; } return (data || []).map((l: any) => ({ id: l.id, name: l.name, category: l.category_id, type: 'GEOJSON', data: l.data, color: l.color, opacity: l.opacity, isVisible: l.is_visible, url: l.file_url, addedDate: l.created_at ? new Date(l.created_at).toISOString().split('T')[0] : '' })); } catch(e) { logError('utility_layers_ex', e); return []; } },
  async addMapLayer(layer: Omit<ExternalMapLayer, 'id' | 'addedDate'>): Promise<ExternalMapLayer | null> { if (!supabase) return null; const { data, error } = await supabase.from('utility_layers').insert({ name: layer.name, category_id: layer.category, type: 'GEOJSON', data: layer.data, color: layer.color, opacity: layer.opacity, is_visible: layer.isVisible, file_url: layer.url }).select().single(); return error ? null : { id: data.id, name: data.name, category: data.category_id, type: 'GEOJSON', data: data.data, color: data.color, opacity: data.opacity, isVisible: data.is_visible, url: data.file_url, addedDate: new Date(data.created_at).toISOString().split('T')[0] }; },
  async deleteMapLayer(id: string): Promise<boolean> { if (!supabase) return false; const { error } = await supabase.from('utility_layers').delete().eq('id', id); return !error; },
  async toggleMapLayer(id: string, isVisible: boolean): Promise<boolean> { if (!supabase) return false; const { error } = await supabase.from('utility_layers').update({ is_visible: isVisible }).eq('id', id); return !error; },
  async fetchDesignLayers(): Promise<DesignLayer[]> { if (!supabase) return []; try { const { data, error } = await supabase.from('design_layers').select('*'); if (error) { logError("design_layers", error); return []; } return (data || []).map((l: any) => ({ id: l.id, name: l.name, type: 'GEOJSON', data: l.data, color: l.color, opacity: l.opacity, isVisible: l.is_visible, createdAt: l.created_at })); } catch(e) { logError('design_layers_ex', e); return []; } },
  async addDesignLayer(layer: Omit<DesignLayer, 'id' | 'createdAt'>): Promise<DesignLayer | null> { if (!supabase) return null; const { data, error } = await supabase.from('design_layers').insert({ name: layer.name, type: 'GEOJSON', data: layer.data, color: layer.color, opacity: layer.opacity, is_visible: layer.isVisible }).select().single(); return error ? null : { id: data.id, name: data.name, type: data.type, data: data.data, color: data.color, opacity: data.opacity, isVisible: data.is_visible, createdAt: data.created_at }; },
  async deleteDesignLayer(id: string): Promise<boolean> { if (!supabase) return false; const { error } = await supabase.from('design_layers').delete().eq('id', id); return !error; },

  // --- MAP NOTES & PHOTOS ---
  async fetchMapData(): Promise<{ notes: MapNote[], photos: SitePhoto[] }> { if (!supabase) return { notes: [], photos: [] }; try { const { data: noteData, error: noteError } = await supabase.from('map_notes').select('*'); if(noteError) logError("map_notes", noteError); const { data: photoData, error: photoError } = await supabase.from('site_photos').select('*'); if(photoError) logError("site_photos", photoError); const notes = (noteData || []).map((n: any) => ({ id: n.id, lat: n.lat, lng: n.lng, text: n.text, author: n.author || '', date: n.date, privacy: n.privacy })); const photos = (photoData || []).map((p: any) => ({ id: p.id, lat: p.lat, lng: p.lng, url: p.url, description: { tr: p.description_tr || '', en: p.description_en || '', ro: p.description_ro || '' }, date: p.date, uploadedBy: p.uploaded_by })); return { notes, photos }; } catch(e) { logError('map_data_ex', e); return { notes: [], photos: [] }; } },
  async addMapNote(note: Omit<MapNote, 'id'>, userId: string): Promise<MapNote | null> { if (!supabase) return null; const { data, error } = await supabase.from('map_notes').insert({ lat: note.lat, lng: note.lng, text: note.text, author: userId, date: note.date, privacy: note.privacy || 'public' }).select().single(); if(error) { logError("map_notes", error); return null; } return { id: data.id, lat: data.lat, lng: data.lng, text: data.text, author: data.author || '', date: data.date, privacy: data.privacy }; },
  async deleteMapNote(id: string): Promise<boolean> { if (!supabase) return false; const { error } = await supabase.from('map_notes').delete().eq('id', id); if (error) logError('deleteMapNote', error); return !error; },
  async addSitePhoto(photo: Omit<SitePhoto, 'id'>, userId: string): Promise<SitePhoto | null> { if (!supabase) return null; const { data, error } = await supabase.from('site_photos').insert({ lat: photo.lat, lng: photo.lng, url: photo.url, description_tr: photo.description.tr, description_en: photo.description.en, description_ro: photo.description.ro, date: photo.date, uploaded_by: userId }).select().single(); if (error) { logError('addSitePhoto', error); return null; } return { id: data.id, lat: data.lat, lng: data.lng, url: data.url, description: { tr: data.description_tr, en: data.description_en, ro: data.description_ro }, date: data.date, uploadedBy: data.uploaded_by }; },
  async deleteSitePhoto(id: string): Promise<boolean> { if (!supabase) return false; const { error } = await supabase.from('site_photos').delete().eq('id', id); if (error) logError('deleteSitePhoto', error); return !error; },

  // --- POLYGONS (SURVEY POINTS) ---
  async getPolygonsPaginated(page: number, limit: number, search: string): Promise<{ data: PolygonPoint[], count: number }> { if (!supabase) return { data: [], count: 0 }; try { let query = supabase.from('survey_points').select('*', { count: 'exact' }); if (search) query = query.or(`polygon_no.ilike.%${search}%,description.ilike.%${search}%`); const from = (page - 1) * limit; const to = from + limit - 1; const { data, error, count } = await query.range(from, to).order('polygon_no', { ascending: true }); if (error) { logError('getPolygonsPaginated', error); return { data: [], count: 0 }; } return { data: (data || []).map(mapPolygonFromDB), count: count || 0 }; } catch(e) { logError('getPolygonsPaginated_ex', e); return { data: [], count: 0 }; } },
  async getAllPolygons(): Promise<PolygonPoint[]> { if (!supabase) return []; try { const { data, error } = await supabase.from('survey_points').select('*'); if (error) { logError('getAllPolygons', error); return []; } return data ? data.map(mapPolygonFromDB) : []; } catch(e) { logError('getAllPolygons_ex', e); return []; } },
  async loadDemoPolygons(): Promise<boolean> { 
      // Empty stub to prevent errors since demo data files are removed
      console.warn("Demo Data loading is deprecated/removed.");
      return false; 
  },
  async upsertPolygon(point: any): Promise<PolygonPoint | null> { if(!supabase) return null; const payload = { polygon_no: point.polygonNo, road_name: point.roadName, km: point.km, offset_val: point.offset, east: point.east, north: point.north, elevation: point.elevation, lat: point.lat, lng: point.lng, description: point.description, status: point.status }; if(point.id && point.id.length > 20) (payload as any).id = point.id; const {data, error} = await supabase.from('survey_points').upsert(payload).select().single(); if (error) { logError('upsertPolygon', error); return null; } return error ? null : mapPolygonFromDB(data); },
  async deletePolygon(id: string): Promise<boolean> { if(!supabase) return false; const {error} = await supabase.from('survey_points').delete().eq('id', id); if (error) logError('deletePolygon', error); return !error; },
  async bulkInsertPolygons(points: any[]): Promise<boolean> { if(!supabase) return false; const payload = points.map(p => ({ polygon_no: p.polygonNo, road_name: p.roadName, km: p.km, offset_val: p.offset, east: p.east, north: p.north, elevation: p.elevation, lat: p.lat, lng: p.lng, description: p.description, status: p.status })); const {error} = await supabase.from('survey_points').insert(payload); if (error) logError('bulkInsertPolygons', error); return !error; },
  async bulkInsertChainage(markers: any[]): Promise<boolean> { return true; },
};
