
import { supabase } from '../supabase';
import { PVLAStructure, PVLAFile, MatrixColumn, PVLAIndexConfig, ProgressRow } from '../../types';
import { logError } from '../dbUtils';

export const pvlaRepository = {
  // --- PVLA ---
  async fetchPvlaStructures(): Promise<PVLAStructure[]> { if(!supabase) return []; try { const { data, error } = await supabase.from('pvla_structures').select('*').order('name', { ascending: true }); if(error) { logError("pvla_structures", error); return []; } return (data || []).map((s: any) => ({ id: s.id, name: s.name, km: s.km, type: s.type, path: s.path })); } catch(e) { logError('pvla_structures_ex', e); return []; } },
  async addPvlaStructure(s: Omit<PVLAStructure, 'id'>): Promise<PVLAStructure | null> { if(!supabase) return null; const { data, error } = await supabase.from('pvla_structures').insert(s).select().single(); return error ? null : { id: data.id, name: data.name, km: data.km, type: data.type, path: data.path }; },
  async deletePvlaStructure(id: string): Promise<boolean> { if(!supabase) return false; const { error } = await supabase.from('pvla_structures').delete().eq('id', id); return !error; },
  async fetchPVLAFiles(structureId?: string): Promise<PVLAFile[]> { if(!supabase) return []; try { let query = supabase.from('pvla_files').select('*').order('date', { ascending: false }); if(structureId) query = query.eq('structure_id', structureId); const { data, error } = await query; if(error) { logError("pvla_files", error); return []; } return data.map((f: any) => ({ id: f.id, name: f.name, type: f.type, structureId: f.structure_id, structureName: f.structure_name, date: f.date, size: f.size, path: f.path })); } catch(e) { logError('pvla_files_ex', e); return []; } },
  async addPVLAFile(f: Omit<PVLAFile, 'id'>): Promise<PVLAFile | null> { if(!supabase) return null; const { data, error } = await supabase.from('pvla_files').insert({ name: f.name, type: f.type, structure_id: f.structureId, structure_name: f.structureName, date: f.date, size: f.size, path: f.path }).select().single(); return error ? null : { id: data.id, name: data.name, type: data.type, structureId: data.structure_id, structureName: data.structure_name, date: data.date, size: data.size, path: data.path }; },
  async deletePVLAFile(id: string): Promise<boolean> { if(!supabase) return false; const { error } = await supabase.from('pvla_files').delete().eq('id', id); return !error; },
  async fetchMatrixColumns(): Promise<{ Bridge: MatrixColumn[]; Culvert: MatrixColumn[] }> { const columns = { Bridge: [] as MatrixColumn[], Culvert: [] as MatrixColumn[] }; if (!supabase) return columns; try { const { data, error } = await supabase.from('pvla_matrix_columns').select('*').order('order_index'); if (error) { logError("pvla_matrix_columns", error); return columns; } (data || []).forEach((col: any) => { const mappedCol: MatrixColumn = { id: col.id, name: { tr: col.name_tr, en: col.name_en, ro: col.name_ro }, group: { tr: col.group_tr, en: col.group_en, ro: col.group_ro }, type: col.col_type }; if (col.type === 'Bridge') columns.Bridge.push(mappedCol); else if (col.type === 'Culvert') columns.Culvert.push(mappedCol); }); return columns; } catch(e) { logError('pvla_matrix_columns_ex', e); return columns; } },
  async addMatrixColumn(type: 'Bridge'|'Culvert', col: MatrixColumn): Promise<MatrixColumn | null> { if (!supabase) return null; const { data, error } = await supabase.from('pvla_matrix_columns').insert({ id: col.id, type, name_tr: col.name.tr, name_en: col.name.en, name_ro: col.name.ro, group_tr: col.group.tr, group_en: col.group.en, group_ro: col.group.ro, col_type: col.type }).select().single(); if (error) { logError('addMatrixColumn', error); return null; } return { id: data.id, name: { tr: data.name_tr, en: data.name_en, ro: data.name_ro }, group: { tr: data.group_tr, en: data.group_en, ro: data.group_ro }, type: data.col_type }; },
  async updateMatrixColumn(id: string, col: Partial<MatrixColumn>): Promise<boolean> { if (!supabase) return false; const payload: any = { col_type: col.type }; if (col.name) { payload.name_tr = col.name.tr; payload.name_en = col.name.en; payload.name_ro = col.name.ro; } if (col.group) { payload.group_tr = col.group.tr; payload.group_en = col.group.en; payload.group_ro = col.group.ro; } const { error } = await supabase.from('pvla_matrix_columns').update(payload).eq('id', id); if (error) logError('updateMatrixColumn', error); return !error; },
  async deleteMatrixColumn(id: string): Promise<boolean> { if (!supabase) return false; const { error } = await supabase.from('pvla_matrix_columns').delete().eq('id', id); if (error) logError('deleteMatrixColumn', error); return !error; },
  async fetchPvlaIndices(): Promise<{ Bridge: PVLAIndexConfig; Culvert: PVLAIndexConfig }> { const indices = { Bridge: { title: { tr: '', en: '', ro: '' }, description: { tr: '', en: '', ro: '' }, fileUrl: '#', lastUpdated: '-' }, Culvert: { title: { tr: '', en: '', ro: '' }, description: { tr: '', en: '', ro: '' }, fileUrl: '#', lastUpdated: '-' } }; if (!supabase) return indices; try { const { data, error } = await supabase.from('pvla_indices').select('*'); if (error) { logError("pvla_indices", error); return indices; } (data || []).forEach((idx: any) => { if (idx.type === 'Bridge' || idx.type === 'Culvert') { indices[idx.type as 'Bridge' | 'Culvert'] = { title: { tr: idx.title_tr, en: idx.title_en, ro: idx.title_ro }, description: { tr: idx.desc_tr, en: idx.desc_en, ro: idx.desc_ro }, fileUrl: idx.file_url || '#', lastUpdated: idx.last_updated || '-' }; } }); return indices; } catch(e) { logError('pvla_indices_ex', e); return indices; } },
  async updatePvlaIndex(type: 'Bridge'|'Culvert', config: Partial<PVLAIndexConfig>): Promise<boolean> { if (!supabase) return false; const payload: any = { file_url: config.fileUrl, last_updated: config.lastUpdated }; if (config.title) { payload.title_tr = config.title.tr; payload.title_en = config.title.en; payload.title_ro = config.title.ro; } if (config.description) { payload.desc_tr = config.description.tr; payload.desc_en = config.description.en; payload.desc_ro = config.description.ro; } const { error } = await supabase.from('pvla_indices').upsert({ type, ...payload }, { onConflict: 'type' }); if (error) logError('updatePvlaIndex', error); return !error; },
  async fetchMatrix(): Promise<ProgressRow[]> { if(!supabase) return []; try { const { data, error } = await supabase.from('progress_matrix').select('*').order('order_index'); if(error) { logError("progress_matrix", error); return []; } return (data || []).map((r: any) => ({ id: r.id, structureId: r.structure_id, location: r.location, foundationType: r.foundation_type, orderIndex: r.order_index, cells: r.cells || {} })); } catch(e) { logError('progress_matrix_ex', e); return []; } },
  async addMatrixRow(row: ProgressRow): Promise<boolean> { if(!supabase) return false; const { error } = await supabase.from('progress_matrix').insert({ id: row.id, structure_id: row.structureId, location: row.location, foundation_type: row.foundationType, order_index: row.orderIndex, cells: row.cells }); if (error) logError('addMatrixRow', error); return !error; },
  async deleteMatrixRow(id: string): Promise<boolean> { if(!supabase) return false; const { error } = await supabase.from('progress_matrix').delete().eq('id', id); if (error) logError('deleteMatrixRow', error); return !error; },
  async updateMatrixCell(rowId: string, cells: any): Promise<boolean> { if(!supabase) return false; const { error } = await supabase.from('progress_matrix').update({ cells: cells }).eq('id', rowId); if (error) logError('updateMatrixCell', error); return !error; },
};
